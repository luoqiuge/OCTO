哈希函数
1 假设一个计算中的寄存器，有四位。如果表示无符号的整数，可以用来表示
0-15。

假设这个寄存器上原来有一个数字3，然后我们反复对其进行乘5的操作
寄存器中：3 15 11 7   3
实际运算：3 15 75 375 1875

我们看到，上面定义了一种新的运算。其结果会被限制在一个有限的空间内。
广义上讲，任何运算结果在一个闭合空间内的函数，都可以被认为是一个哈希
函数。

===哈希表===

为了提高查询速度，我们设计了二叉树；但是二叉树必须有序才有意义。对于
数值类的数据，我们其实另有快速查找的办法。

如果数字不重复，而且范围有限，是可以用下标对应的方式进行快速查找的。
例如，有0-9是个数字，我们就可以建立一个长度为10的数组，把上述内容存
到对应的下标即可。

哈希表就是利用上述特征，只不过把直接映射关系变成了一个自定义的哈希函
数来完成。

===哈希表的实现===
1 要有好的哈希函数，可以让各种输入尽量均匀的散布到一个不确定长度的范
围内。

2 碰撞是没有办法避免的，那么如何解决碰撞。

3 查找（必须考虑碰撞）

4 扩展。如果数据持续增加，就要对原有的数组进行扩展。这时，要根据新的数
组的大小调整hash函数（至少mod的值要发生变化）。基本方法是新建一个大的数
组，然后把原有表中的内容根据新的hash结果存入新表。

===hashcode和equals方法====
1 如果参考hash表的实现，我们就能够理解，为什么如果需要在HashSet这样的
工具类中让两个不同的值相等的对象被HashSet理解为相等，就必须同时实现（
重写）其hashcode和equals方法

2 因为hashcode提供了快速定位，如果hashcode不同，HashSet这样的工具会立
即认为两个对象不相等，不会去考虑equals方法。只有当hashcode方法返回结果
是一致的，才会进一步用equals方法进行细节判定

3 可以简单的认为hashcode提供了粗筛，equals提供了最终判定。
上述原则同样适用于HashMap这样的工具对key的判定

4 因此，一般情况下，不建议大家使用自定义的对象作为Map的key，而推荐大家
使用String或者Integer类作为key

为什么:第一，自定义对象一定要重写hashcode和equals方法；费时费力，还不
一定有效；第二，String和Integer类都已经重写了hashcode和equals方法，虽
然String的hashcode方法是某个大神随手写出来的，有一定的问题，但是大量的
Map工具对此自有解决方案；最后，几乎所有的大数据解决方案中，key都是String
类型的（因为这和语言无关）。

又及：Object默认的hashcode方法对于两个不同的对象不等，equals方法对于两
个不同的对象不等。

720
===JAVA常量内联===
1 JAVA编译器默认会内联常量的使用。即，不是通过类名加常量名的方式调用常量
而是把常量的值复制到引用的位置。

2 因此，就有可能发生下述情况：当常量的内容发生变化的时候，起引用的位置
的值没有发生变化。特别是在大型的项目中，常量被其它包所引用的情况下

3 Java编译器之所以这么做，显然是在认为常量一旦定义就不会修改的前提。
这也要求我们在设计定义常量的时候更加小心，尽量定义有意义，且不怎么会发
生变化的内容

如果常量确实需要变化，那么，请在改动前认真调查所有引用这个常量的代码。
所有相关的代码必须重新编译

===工具类===

在JAVA中，常用复数的名字表示工具类：Arrays,Objects(jdk 7+),Collections.

工具类的特征就是，只有常量和静态方法，且构造方法私有化。从某一个角度看，
工具类就是单例的一个变种。

在Spring大行其道的今天，工具类其实也可以用普通类的实例方法来实现，然后
交给Spring，说它是一个单例就好了
所以在java中，在描述Model的时候，请回避复数的类名。
引申出来，在数据库中，表名永远都是单数。因为表本身就是可以存储复数内容
的（一行就是一个记录，表是可以存储多行的，自然就内含了复数含义。news是个
例外）。

